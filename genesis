#!/usr/bin/env python
# -*- coding: utf-8 -*-
version = "0.1"

import re
import sys
import argparse

# ======================================================================

class Parser:
    """
    The parser looks through the tokens to determine what is the stem and
    what are the options.
    """

    # Properties
    # ------------------------------------------------------------------

    # Property: str
    # The string
    str = ''

    # Property: tokens
    # The list of tokens
    tokens = []

    # Constructor
    # ------------------------------------------------------------------

    def __init__(self, str):
        self.str = str
        self.tokens  = []
        self._tokenize()

    # Protected methods
    # ------------------------------------------------------------------

    def _tokenize(self):
        """Tokenizes.
        Initializes [[self.tokens]].
        """

        str = self.str.strip()

        # Find prefix/suffix
        #~ while True:
            #~ match = re.match(r"^(\s*<[^>]+>\s*)", str)
            #~ if match is None: break
            #~ if self.prefix is None: self.prefix = ''
            #~ self.prefix += match.group(0)
            #~ str = str[len(match.group(0)):]
#~
        #~ while True:
            #~ match = re.findall(r"(\s*<[^>]+>[\s\n\r]*)$", str)
            #~ if not match: break
            #~ if self.suffix is None: self.suffix = ''
            #~ self.suffix = match[0] + self.suffix
            #~ str = str[:-len(match[0])]

        # Split by the element separators
        for token in re.split('(.*)', str):
            if token.strip() != '':
                self.tokens.append(token)

    # Public methods
    # ------------------------------------------------------------------

    def parse(self):
        """Parses.
        Called by [[Router]].
        """
        if len(self.tokens) == 0: return

        options_cnt = len(self.tokens) - 1
        output = "stem: %s\n" % self.tokens[0]

        for o in self.tokens[1:]:
            output += "option: %s\n" % o

        output += 'stats: stem is %d bytes long, %d option%s found\n' % (
            len(self.tokens[0]),
            options_cnt,
            's' if options_cnt != 1 else ''
            )

        return output

# ======================================================================

class Router:
    """
    The router collects all the input data and prepares it for parsing.
    """

    # Properties
    # ------------------------------------------------------------------

    # Property: options
    # Command line arguments
    options = None

    # Property: output
    # The rendered output
    output = ''

    # Constructor
    # ------------------------------------------------------------------

    def __init__(self):
        pass

    # Methods
    # ------------------------------------------------------------------

    def parse_args(self, options=sys.argv[1:]):
        print 'parge_args(): options: ', options
        global version

        parser = argparse.ArgumentParser(
            description='Parses and tokenizes text.',
            epilog='Refer to the documentation for more detailed information.',
            prog=sys.argv[0],
            )

        parser.add_argument('-v', '--version', action='version', 
                            version='%(prog)s ' + version,
                            help='print the version information and exit')

        parser.add_argument('input', metavar='INPUT', type=str, nargs='?',
                            help='input string')

        parser.add_argument('--inputfile', type=str, metavar='FILE',
                            help='input file')

        args = parser.parse_args(options)

        print 'parge_args(): ', repr(args)
        self.options = args

    def start(self):
        #~ import pdb; pdb.set_trace()
        filestr = inputstr = ''

        print 'start(): self.options: ', repr(self.options)

        if (self.options.inputfile):
            print 'adding file'
            try:
                f = open(self.options.inputfile, 'rb')
                #self.input = [x.strip() for x in f if x.strip()]
                filestr = f.read()
                f.close()

            except TypeError:
                print 'file error'

        if (self.options.input):
            print 'adding input'
            inputstr = self.options.input

        self.render(('\n'.join((filestr, inputstr))).strip())

    def render(self, str=None):
        print 'parse() str: %s "%s"' % (type(str), str)

        try:
            if str:
                lines = str
            else:
                print 'Enter input text (ctrl-D to end)'
                lines = [sys.stdin.read()]
                lines = " ".join(lines)

        except KeyboardInterrupt:
            pass

        except:
            sys.stderr.write("Reading failed.\n")
            return

        try:
            self.parser = Parser(lines)
            #self.parser.load_string(lines)
            self.output = self.parser.parse()

        except ParsingError:
            sys.stderr.write("Parse error. Check your input.")
            print sys.exc_info()[0]
            print sys.exc_info()[1]

# ======================================================================

if __name__ == "__main__":
    r = Router()
    r.parse_args()
    r.start()
    print r.output
